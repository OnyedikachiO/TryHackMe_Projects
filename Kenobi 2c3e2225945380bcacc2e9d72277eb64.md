# Kenobi

A full walkthrough of exploiting a Linux host from enumerating Samba shares, exploiting a vulnerable ProFTPD service, to escalating privileges through PATH variable manipulation.

### Enumerating Samba for shares

Samba is the standard Windows interoperability suite for Linux and Unix. It lets users access shared files, printers, and other resources across a company’s intranet or the internet. Essentially, it serves as a network file-sharing system.

Samba implements the Server Message Block (SMB) protocol, a Windows-native protocol, allowing non-Windows systems to communicate seamlessly. Without Samba, Linux and Unix machines would remain isolated from Windows systems, even when connected to the same network

Using **Nmap**, we can enumerate a target for SMB shares. Nmap can automate a wide range of network discovery tasks, and it includes scripts specifically for SMB enumeration.

[](https://www.notion.so)

```bash
nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.80.171.65
```

SMB typically runs on **ports 445 and 139**.

Running the command above revealed **3 SMB shares**.

![1.png](1.png)

Most Linux distributions already include **smbclient**, so we can inspect one of the shares:

```bash
smbclient //10.80.171.65/anonymous
```

![2.png](4e4d1c2e-8e1c-404d-b9a3-b06b50b98281.png)

Once connected, listing the directory contents shows a single file:

**log.txt**

You can also recursively download the entire share (no username or password needed):

```bash
smbget -R smb://10.80.171.65/anonymous
```

![3.png](3.png)

Opening *log.txt* reveals two key pieces of information:

- SSH key generation details for the user **Kenobi**
- Information about the **ProFTPD** server

![4.png](4.png)

From this, we confirm FTP is running on **port 21**.

A previous Nmap scan also showed **port 111**, which runs **rpcbind,** a service that maps RPC program numbers to network addresses. In this case, it provides access to an NFS export.

We can enumerate the NFS share with:

```bash
nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.80.171.65
```

The visible mount is:

**/var**

### Gain initial access with ProFtpd

**ProFTPD** is a free, open-source FTP server compatible with both Unix and Windows systems. Older versions have had several vulnerabilities, making them useful targets during exploitation exercises.

To begin, we first identify the ProFTPD version by connecting with netcat:

```bash
nc 10.80.171.65 21
```

**Version:** **1.3.5**

Using **searchsploit**, on [https://www.exploit-db.com/](https://www.exploit-db.com/) we can look for known exploits affecting this version:

![chrome_cuITgzNxc0.png](chrome_cuITgzNxc0.png)

**Number of matching exploits:** **4**

Among these, you should find a vulnerability related to **ProFTPD’s mod_copy module**.

The **mod_copy** module implements the commands `SITE CPFR` (copy from) and `SITE CPTO` (copy to). These commands let an unauthenticated user copy files or directories to arbitrary locations on the server. Since the FTP service runs as the **Kenobi** user (as noted earlier), we can leverage this to copy Kenobi’s private SSH key.

![5.png](5.png)

Using these commands, we move Kenobi’s private key into the **/var/tmp** directory—an NFS mount we previously enumerated.

Next, we mount the exported NFS share on our own machine:

```
mkdir /mnt/kenobiNFS
mount 10.80.171.65:/var /mnt/kenobiNFS
ls -la /mnt/kenobiNFS
```

![6.png](6.png)

![7.png](7.png)

![8.png](8.png)

This gives us direct access to the remote `/var` directory. From here, we can retrieve the SSH private key from `/var/tmp`, authenticate as **kenobi**, and access the account.

![9.png](9.png)

![10.png](10.png)

![11.png](11.png)

**Question:** *What is Kenobi’s user flag?*

**Location:** `/home/kenobi/user.txt`

![12.png](12.png)

### Privilege Escalation with Path Variable Manipulation

![image.png](image.png)

Before proceeding, let’s break down **SUID**, **SGID**, and the **Sticky Bit**, since they play a major role in privilege escalation.

| **Permission** | **On Files** | **On Directories** |
| --- | --- | --- |
| **SUID Bit** | Executes the file with the permissions of the file **owner** |  |
| **SGID Bit** | Executes the file with the permissions of the **group owner** | Files created inherit the directory’s group ownership |
| **Sticky Bit** | No practical meaning | Prevents users from deleting files they don’t own |

SUID binaries can be dangerous. Some legitimate ones, like `passwd` need elevated privileges to function. But when a custom or misconfigured binary has the SUID bit set, it can open the door to privilege escalation.

To locate SUID binaries on the system:

```bash
find / -perm -u=s -type f 2>/dev/null
```

![13.png](13.png)

Among the results, one file clearly stands out:

**/usr/bin/menu**

Running the binary presents **3 options**.

![14.png](14.png)

Next, using the **strings** command reveals that the binary calls external programs **without using absolute paths** (e.g., it calls `curl` instead of `/usr/bin/curl`).

```bash
curl -l localhost
uname -r
ifconfig
```

Because **menu** runs with root privileges, this allows us to manipulate the `PATH` environment variable and hijack the execution.

![15.png](15.png)

By creating a fake `curl` (actually a copy of `/bin/sh`), assigning execute permissions, and placing its directory at the start of our PATH, `menu` ends up launching **our shell**, but with **root privileges**.

This gives us full root access.

**Final Question:**

*What is the root flag?*

Location: **/root/root.txt**

![16.png](16.png)